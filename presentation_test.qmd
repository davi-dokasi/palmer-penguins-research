---
title: Desvendando o Mundo dos Penguins com o Dataset Palmer Penguins üêß
title-slide-attributes:
    data-background-image: bg_img/penguins_bg.png
    data-background-size: contain
    data-background-opacity: "0.35"

format: 
  revealjs:
    scrollable: true
    logo: bg_img/tux.png
    footer: Davi Augusto, Diogo Bolzan, Jo√£o Arend, Luan Frederico
    theme: [default, dd.scss]
    
---
```{r libraries, include=FALSE, warning=FALSE}

library(readr)
library(dplyr)
library(gridExtra)
library(patchwork)
library(ggplot2)
library(magick)
library(tidyr)
library(kableExtra)
library(htmlwidgets)
library(leaflet)
```

```{r setting_vars, include=FALSE, warning=FALSE}
# DOCUMENTA√á√ÉO DO QUARTO https://quarto.org/docs/presentations/revealjs/

#Carregando o Data Base Penguins:
penguins_db <- read_csv("penguins.csv")

# Header para tabelas knit do database original
penguins_db_header <- c("Index", "Specie",
                        "Island", "Bill Length (mm)",
                        "Bill Depth (mm)", "Flipper Length (mm)",
                        "Body Mass (g)", "Sex", "Year")

#Criando um subset para cada esp√©cie:
species_unique <- unique(penguins_db$species)
islands_unique <- unique(penguins_db$island)
nrows_species <- c()
nrows_species_male <- c()
nrows_species_female <- c()

for (spec in species_unique) {
  # Banco de dados
  subset_name <- paste("species_separadas_", tolower(spec), sep = "")
  assign(subset_name, penguins_db[penguins_db$species == spec, ])
  # N√∫mero de registros por esp√©cie
  nrows_name <- paste("nrows_", tolower(spec), sep = "")
  assign(nrows_name, nrow(penguins_db[penguins_db$species == spec, ]))

  nrows_species <- c(nrows_species,
                     nrow(penguins_db[penguins_db$species == spec, ]))

  nrows_species_male <- c(nrows_species_male,
                          nrow(penguins_db[penguins_db$species == spec &
                                             penguins_db$sex == "male", ]))

  nrows_species_female <- c(nrows_species_female,
                            nrow(penguins_db[penguins_db$species == spec &
                                               penguins_db$sex == "female", ]))
}

media_adelie <- colMeans(species_separadas_adelie[c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g")], na.rm = TRUE)
media_chinstrap <- colMeans(species_separadas_chinstrap[c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g")], na.rm = TRUE)
media_gentoo <- colMeans(species_separadas_gentoo[c("bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g")], na.rm = TRUE)

```
# Introdu√ß√£o

## Sobre o Dataset 

::: columns
::: {.column width="55%"}
- Al√©m de um banco de dados no Kaggle, √© um banco de dados "verdadeiro" e nativo do R

- Os dados foram coletados e disponibilizados pela Dra. Kristen Gorman e pela Esta√ß√£o Palmer, Ant√°rtica, LTER (Long Term Ecological Research), membro da Rede de Pesquisa Ecol√≥gica de Longo Prazo.

- 344 Pinguins

- 3 esp√©cies (Ad√©lie, chinstrap e gentoo)
:::

::: {.column width="45%"}
![](bg_img/kristen.jpg){.absolute  width="400" height="400"}

:::
:::

## Contexto

::: columns
::: {.column width="55%"}

- Coletados em Palmer Station, na Pen√≠nsula Ant√°rtica, esses dados oferecem insights valiosos sobre tr√™s esp√©cies de pinguins: Ad√©lie, Chinstrap e Gentoo. 
- Cada linha neste conjunto de dados √© mais do que um simples registro; √© uma hist√≥ria de sobreviv√™ncia, reprodu√ß√£o e evolu√ß√£o em um dos ambientes mais extremos do planeta.
:::

::: {.column width="45%"}
![](bg_img/madagascar.png){.absolute  width="450" height="300"}
:::
:::

## Apresentando o dataset

::: columns
::: {.column width="62%"}
Exemplo de uma pequena amostra aleat√≥ria do dataset:

```{r penguinsdb_sample}

knitr::kable(na.omit(penguins_db)[sample(nrow(na.omit(penguins_db)), 8), 2:ncol(penguins_db)],
  col.names = penguins_db_header[-1],
  align = "ccrrrrcc"
)  %>%
  kable_styling(full_width = F, font_size = 17)
   
```
:::
::: {.column width="38%"}

![](bg_img/var_explanation.png){.absolute  width="380" height="auto"}

:::
:::

## Nossos Protagonistas

::: columns
::: {.column width="33%" .fragment}
- Ad√©lie 
 ![](bg_img/adelie_1.jpeg){width="290" height="auto"}
 
```{r}

knitr::kable(media_adelie, 
      col.names = "M√©dias") %>%
  kable_styling(full_width = F, position = "center", font_size = 18)
```
:::

::: {.column width="33%" .fragment}
- Chinstrap
 ![](bg_img/chinstrap.jpeg){width="290" height="auto"}
 
```{r attr.output='.incremental'}

knitr::kable(media_chinstrap, 
      col.names = "M√©dias") %>%
  kable_styling(full_width = F, position = "center", font_size = 18)
```

:::

::: {.column width="33%" .fragment}
- Gentoo
 ![](bg_img/gentoo.jpeg){width="290" height="auto"}
 
```{r attr.output='.incremental'}

knitr::kable(media_gentoo, 
      col.names = "M√©dias") %>%
  kable_styling(full_width = F, position = "center", font_size = 18)
```

:::
:::
## Sobre as esp√©cies
::: {.panel-tabset}

### Vis√£o Geogr√°fica
```{r geo_map}

leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=-65.5000, lat=-65.4333, popup="Biscoe Island") %>%
  addMarkers(lng=-64.2333 , lat=-64.7333, popup="Dream Island") %>%
  addMarkers(lng=-64.083333, lat=-64.7666636, popup="Torgersen Island") %>%
  addProviderTiles("Esri.WorldImagery")

```

### Ocupa√ß√£o

```{r habitat}

penguis_island_presence <- penguins_db %>%
  group_by(species, island) %>%
  summarise(contagem = n(), .groups = "drop")

ggplot(penguis_island_presence, aes(x=island, y=species, fill = contagem)) +
  geom_tile() + 
  geom_text(aes(label = contagem), color = "white", size = 4) + 
  labs(x = "",
       y = "") + 
  theme_bw() + 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

```

### Observa√ß√µes

::: columns
::: {.column width="70%"}
```{r species_resum_min_max}

species_resum <- penguins_db %>%
  group_by(species) %>%
  summarize(nrows_species = n(),
    male_count = sum(ifelse(sex == "male", 1, 0), na.rm = TRUE),
    female_count = sum(ifelse(sex == "female", 1, 0), na.rm = TRUE),
    bill_length_min = min(bill_length_mm, na.rm = TRUE),
    bill_length_max = max(bill_length_mm, na.rm = TRUE),
    bill_depth_min = min(bill_depth_mm, na.rm = TRUE),
    bill_depth_max = max(bill_depth_mm, na.rm = TRUE),
    flipper_length_min = min(flipper_length_mm, na.rm = TRUE),
    flipper_length_max = max(flipper_length_mm, na.rm = TRUE),
    body_mass_min = min(body_mass_g, na.rm = TRUE),
    body_mass_max = max(body_mass_g, na.rm = TRUE),
  ) %>%
  rename(
    "Total de registros" = nrows_species,
    "Quant. de machos" = male_count,
    "Quant. de f√™meas" = female_count,
    "Menor comprimento do bico (mm)" = bill_length_min,
    "Maior comprimento do bico (mm)" = bill_length_max,
    "Menor profundidade do bico (mm)" = bill_depth_min,
    "Maior profundidade do bico (mm)" = bill_depth_max,
    "Menor comprimento da nadadeira (mm)" = flipper_length_min,
    "Maior comprimento da nadadeira (mm)" = flipper_length_max,
    "Menor massa corporal (g)" = body_mass_min,
    "Maior massa corporal (g)" = body_mass_max
  )

knitr::kable(t(species_resum[, 2:ncol(species_resum)]),
             col.names = c(species_resum$species)) %>%
  kable_styling(font_size = 17.5)
 
```
:::
::: {.column width="30%"}

![](bg_img/pingu.png){width="100%" height="auto"}

:::
:::
### Propor√ß√µes F√≠sicas 

Rela√ß√£o entre comprimento da nadadeira e massa corporal
```{r body_mass_flipper}

ggplot(data=penguins_db,aes(x=flipper_length_mm,y=body_mass_g)) +
  geom_point(aes(shape=species,color=species), size = 2) + 
  labs(x = "Comprimento da nadadeira (mm)",
       y = "Massa Corporal (g)") + 
  theme_bw() + 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0),
        text = element_text(size = 12))
 
ggplot(data=subset(penguins_db, sex %in% c("male", "female")))+
  geom_point(mapping=aes(x=flipper_length_mm, y=body_mass_g, color=species,shape=species))+
  labs(x = "Comprimento da nadadeira (mm)",
       y = "Massa Corporal (g)") + 
  facet_wrap(~sex) + 
  theme_bw()+ 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0),
        text = element_text(size = 12))

```

Compara√ß√£o da distribui√ß√£o da massa corporal por esp√©cie
```{r boxplot}

ggplot(penguins_db, aes(x = species, y = body_mass_g, fill = species)) +
  geom_boxplot() +
  labs(x = "Esp√©cie",
       y = "Massa (g)") +
  theme_bw() + 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0),
        text = element_text(size = 12))

```

Rela√ß√£o entre comprimento e profundidade do bico
```{r bill_lenght_depth}

ggplot(data=penguins_db,aes(x=bill_length_mm,y=bill_depth_mm)) +
  geom_point(aes(shape=species,color=species), size = 2) +
  labs(x = "Comprimento do bico (mm)",
       y = "Profundidade do bico (mm)") + 
  theme_bw() + 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0),
        text = element_text(size = 12))

ggplot(data=subset(penguins_db, sex %in% c("male", "female")))+
  geom_point(mapping=aes(x=bill_length_mm, y=bill_depth_mm, color=species,shape=species))+
  labs(x = "Comprimento do bico (mm)",
       y = "Profundidade do bico (mm)") + 
  facet_wrap(~sex) + 
  theme_bw()+ 
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0),
        text = element_text(size = 12))

```

:::

# Pesquisas

## Estudo Adelie
Com o objetivo de c√°lcular o intervalo de confian√ßa para a esp√©cie Adelie, criamos um data base com apenas as observa√ß√µes da esp√©cie de interesse nele, abaixo est√° o resumo:

::: {.panel-tabset}

### As primeiras 6 observa√ß√µes:

```{r Data Base Explica√ß√£o, warning=FALSE}

knitr::kable(head(species_separadas_adelie[, 2:ncol(species_separadas_adelie)]),
  col.names = penguins_db_header[-1],
  align = "ccrrrrcc"
) %>%
  kable_styling(font_size = 20)

```

### Intervalo de confian√ßa:

Histograma de amostras do comprimento da nadadeira (mm)

```{r Curva Te√≥rica Explica√ß√£o, warning=FALSE, message=FALSE}

set.seed(1234)

ggplot(data = data.frame(x = species_separadas_adelie$flipper_length_mm), aes(x = x)) +
  geom_histogram(color="#164863", fill="#427D9D") +
  labs(x = "Comprimento da Nadadeira (mm)",
       y = "Frequ√™ncia") + 
  theme_bw()+ 
  theme(text = element_text(size = 12)) + 
  geom_text(x = 205, y = 18, label = "Limite Superior: 190.993 mm ", alpha = 0.03) +
  geom_text(x = 205, y = 16.5, label = "Limite Inferior: 188.914 mm ", alpha = 0.03) +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

```

::: footer
.
:::
:::

## IC (Com Bootstrap!)

O que √© e como funciona:

![](bg_img/bootimg.png){.r-stretch width="100%" height="auto"}

```{r, echo = FALSE, include=FALSE}

#O limite inferior feito com a f√≥rmula √© de:
#m√©dia da coluna comprimento do bico
media_adelie <- mean(species_separadas_adelie$flipper_length_mm, na.rm = TRUE)

# z <- qnorm(p = 0.025, mean = 0, sd = 1, lower.tail = FALSE) #Gerando Z-Score para 0.95 dos dados
z <- qnorm(0.025, lower.tail = FALSE)

# n <- length(species_separadas_adelie$species) #tamanho da amostra

n <- nrow(species_separadas_adelie)

sd_adelie <- sd(species_separadas_adelie$flipper_length_mm, na.rm = TRUE) #desvio padr√£o da amostra

#Gerando o limite Inferior pela f√≥rmula:
lim_inf <- media_adelie - z * sd_adelie/sqrt(n)
lim_inf

#Gerando o limite Superior pela f√≥rmula:
lim_sup <- media_adelie + z * sd_adelie/sqrt(n)

```

```{r Informa√ß√µes para Bootstraping, include=FALSE, warning=FALSE}

#Bootstraping para gerar curva te√≥rica
n <- length(species_separadas_adelie$species) #tamanho da amostra

#repeti√ß√µes da amostra
n_repeticoes <- 10000

#vetor que armazena as repeti√ß√µes de amostras
repeticoes_media <- as.numeric(n_repeticoes)

for (i in 1:n_repeticoes) {
  amostra <- sample(species_separadas_adelie$flipper_length_mm,
                    size = n,
                    replace = TRUE)
  repeticoes_media[i] <- mean(amostra, na.rm = TRUE)
}

# Criando o dataframe
data <- data.frame(x = repeticoes_media)

#Limite Inferior Bootstrap
lim_inf_boot  <- qnorm(p = 0.025,
                       mean = mean(repeticoes_media),
                       sd = sd(repeticoes_media,
                       na.rm = TRUE))

#Limite Superior Bootstrap
lim_sup_boot  <- qnorm(p = 0.025,
                       mean = mean(repeticoes_media),
                       sd = sd(repeticoes_media, na.rm = TRUE),
                       lower.tail = FALSE)

# #Armazenando os limites Inferior e Superior:
# lim_inf <- media_adelie - z * sd_adelie/sqrt(n)
# lim_sup <- media_adelie + z * sd_adelie/sqrt(n)

```

## Na pr√°tica
::: {.panel-tabset}

### Intervalo Bootstraping

Histograma das m√©dias geradas pelo BootStraping com Curva Te√≥rica

```{r Intervalo de Confian√ßa,warning=FALSE}

ggplot(data = data, aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)),
  fill = "#FC9E21",
  binwidth = 0.1,
  color = "black") +
  stat_function(fun = dnorm,
                args = list(mean = mean(data$x, na.rm = TRUE), 
                            sd = sd(data$x, na.rm = TRUE)),
                color = "#100818",
                size = 1) +
  theme_bw() +
  labs(title = "Esp√©cie Adelie considerando o comprimento da nadadeira",
       x = "Comprimento da Nadadeira (mm)",
       y = "Densidade",
       fill = "Distribui√ß√£o") +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

```


### IC - Curva Te√≥rica
Verifica-se a curva normal te√≥rica com o IC calculado na curva te√≥rica!

```{r Intervalo com Curva Te√≥rica, warning=FALSE}
#Intervalo de Confian√ßa na curva te√≥rica
ggplot(data = data, aes(x = x)) +
  stat_function(fun = dnorm,
                args = list(mean = mean(data$x, na.rm = TRUE),
                            sd = sd(data$x, na.rm = TRUE)),
                color = "#100818", size = 1) +
  stat_function(fun = dnorm,
                args = list(mean = mean(data$x, na.rm = TRUE),
                            sd = sd(data$x, na.rm = TRUE)),
                geom = "area", fill = "blue",
                alpha = 0.2,
                xlim = c(188, lim_inf)) +
  stat_function(fun = dnorm,
                args = list(mean = mean(data$x, na.rm = TRUE),
                            sd = sd(data$x, na.rm = TRUE)),
                geom = "area", fill = "blue",
                alpha = 0.2,
                xlim = c(lim_sup, 192)) +
  theme_bw() +
  labs(title = "Curva Normal das M√©dias Geradas pelo BootStraping considerando IC",
       subtitle = "Para esp√©cie Ad√©lie considerando o comprimento da nadadeira",
       x = "Comprimento da Nadadeira (mm)",
       y = "Densidade",
       fill = "Distribui√ß√£o") +
  geom_text(x = 191.5, y = 0.7, label = "Limite Inferior: 188.9 mm\nLimite Superior: 190.9 mm ", alpha = 0.03) +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

```
Logo, um intervalo de confian√ßa com um n√≠vel de confian√ßa de 95% indica que, em teoria, se selecion√°ssemos uma amostra de mesmo tamanho de uma mesma popula√ß√£o muitas vezes e calcul√°ssemos o intervalo de confian√ßa para cada uma delas, aproximadamente 95% desses intervalos incluiriam o verdadeiro valor do par√¢metro.

### Compara√ß√£o
Verifica-se que os intervalos de confian√ßa com f√≥rmula 'tradicional' e com Bootstrap s√£o praticamente os mesmos:

```{r Compara√ß√£o, echo = FALSE, warning=FALSE}

comp_table <- matrix(c(lim_inf, lim_inf_boot, lim_sup, lim_sup_boot),
                     nrow = 2, byrow = TRUE)

colnames(comp_table) <- c("F√≥rmula", "Bootstrap")
rownames(comp_table) <- c("Limite Inferior", "Limite Sperior")


knitr::kable(comp_table,
             align = "crr")

```

:::

## Gentoo e Chinstrap!
::: {.panel-tabset}

### √Ånalise Gentoo

```{r Todas, warning=FALSE}
#An√°lise de todas juntas

#Por fim a esp√©cie 	Chinstrap

species_separadas_chinstrap <- penguins_db %>%
  filter(species == "Chinstrap")

n_repeticoes <- 10000 #n√∫mero de repeti√ß√µes de amostras
repeticoes_media_chinstrap <- as.numeric(n_repeticoes) #vetor que armazena as repeti√ß√µes de amostras
for (i in 1:n_repeticoes) {
  amostra <- sample(species_separadas_chinstrap$flipper_length_mm, size = n, replace = TRUE)
  repeticoes_media_chinstrap[i] <- mean(amostra, na.rm = TRUE)
}

lim_inf_boot_chinstrap  <- qnorm(p = 0.025, mean = mean(repeticoes_media_chinstrap), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)) #Limite Inferior
lim_sup_boot_chinstrap  <- qnorm(p = 0.025, mean = mean(repeticoes_media_chinstrap), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE), lower.tail = FALSE) #Limite Superior

#Para esp√©cie Gentoo:

# J√° foi feito esse banco
# species_separadas_gentoo <- penguins_db %>%
#   filter(species == "Gentoo")

#n√∫mero de repeti√ß√µes de amostras
n_repeticoes <- 10000

#vetor que armazena as repeti√ß√µes de amostras
repeticoes_media_gentoo <- as.numeric(n_repeticoes)

for (i in 1:n_repeticoes) {
  amostra <- sample(species_separadas_gentoo$flipper_length_mm, 
                    size = n,
                    replace = TRUE)
  repeticoes_media_gentoo[i] <- mean(amostra, na.rm = TRUE)
}

# Limite Inferior
lim_inf_boot_gentoo <- qnorm(p = 0.025,
                             mean = mean(repeticoes_media_gentoo),
                             sd = sd(repeticoes_media_gentoo, na.rm = TRUE))

# Limite Superior
lim_sup_boot_gentoo <- qnorm(p = 0.025,
                             mean = mean(repeticoes_media_gentoo),
                             sd = sd(repeticoes_media_gentoo, na.rm = TRUE), 
                             lower.tail = FALSE)


#vetor que armazena as repeti√ß√µes de amostras
repeticoes_media_adelie <- as.numeric(n_repeticoes)

for (i in 1:n_repeticoes) {
  amostra <- sample(species_separadas_adelie$flipper_length_mm, 
                    size = n,
                    replace = TRUE)
  repeticoes_media_adelie[i] <- mean(amostra, na.rm = TRUE)
}

# Limite Inferior
lim_inf_boot_adelie <- qnorm(p = 0.025,
                             mean = mean(repeticoes_media_adelie),
                             sd = sd(repeticoes_media_adelie, na.rm = TRUE))

# Limite Superior
lim_sup_boot_adelie <- qnorm(p = 0.025,
                             mean = mean(repeticoes_media_adelie),
                             sd = sd(repeticoes_media_adelie, na.rm = TRUE), 
                             lower.tail = FALSE)

g3 <- ggplot(data = data.frame(x = repeticoes_media_gentoo), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)) ,
                binwidth = 0.1,
                fill = "#3E8F92",
                color = "black") +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_gentoo, na.rm = TRUE), sd = sd(repeticoes_media_gentoo, na.rm = TRUE)),
                color = "black",
                size = 1
                ) +
  theme_bw() +
  labs(title = "Histograma das m√©dias geradas pelo BootStraping",
      subtitle = "Para esp√©cie Gentoo considerando a Vari√°vel Comprimento da Nadadeira",
      x = "Comprimento da Nadadeira (mm)",
      y = "Densidade") +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

g4 <- ggplot(data = data.frame(x = repeticoes_media_gentoo), aes(x = x)) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_gentoo, na.rm = TRUE), sd = sd(repeticoes_media_gentoo, na.rm = TRUE)),
                color = "black",
                size = 1) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_gentoo, na.rm = TRUE), sd = sd(repeticoes_media_gentoo, na.rm = TRUE)),
                geom = "area",
                xlim = c(215, lim_inf_boot_gentoo),
                fill = "#d19b2f",
                alpha = 0.7) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_gentoo, na.rm = TRUE), sd = sd(repeticoes_media_gentoo, na.rm = TRUE)),
                geom = "area",
                xlim = c(lim_sup_boot_gentoo, 220),
                fill = "#d19b2f",
                alpha = 0.7) +
  theme_bw() +
  labs(title = "Curva Normal das m√©dias geradas pelo BootStraping considerando IC",
      subtitle = "Para esp√©cie Gentoo considerando a Vari√°vel Comprimento da Nadadeira",
      x = "Comprimento da Nadadeira (mm)",
      y = "Densidade") +
  geom_text(x = 218.8, y = 0.7, label = "Limite Inferior: 216.1 mm\nLimite Superior: 218.2 mm", alpha = 0.02) +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

grid.arrange(g3,g4)

```
Logo, podemos afirmar que h√° 95% de confian√ßa do intervalo [216.1, 218.2] conter o verdadeiro valor do par√¢metro.

### An√°lise Chinstrap

```{r, warning=FALSE}
n_repeticoes <- 10000 #n√∫mero de repeti√ß√µes de amostras
repeticoes_media_chinstrap <- as.numeric(n_repeticoes) #vetor que armazena as repeti√ß√µes de amostras
for (i in 1:n_repeticoes) {
  amostra <- sample(species_separadas_chinstrap$flipper_length_mm, size = n, replace = TRUE)
  repeticoes_media_chinstrap[i] <- mean(amostra, na.rm = TRUE)
}

lim_inf_boot_chinstrap  <- qnorm(p = 0.025, mean = mean(repeticoes_media_chinstrap), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)) #Limite Inferior
lim_sup_boot_chinstrap  <- qnorm(p = 0.025, mean = mean(repeticoes_media_chinstrap), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE), lower.tail = FALSE) #Limite Superior

g5 <- ggplot(data = data.frame(x = repeticoes_media_chinstrap), aes(x = x)) +
  geom_histogram(aes(y = ..density..) ,
                binwidth = 0.1,
                fill = "#B03060",
                color = "black") +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_chinstrap, na.rm = TRUE), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)),
                color = "black",
                size = 1
                ) +
  theme_bw() +
  labs(title = "Histograma das m√©dias geradas pelo BootStraping",
      subtitle = "Para esp√©cie Chinstrap considerando a Vari√°vel Comprimento da Nadadeira",
      x = "Comprimento da Nadadeira (mm)",
      y = "Densidade") +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

g6 <- ggplot(data = data.frame(x = repeticoes_media_chinstrap), aes(x = x)) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_chinstrap, na.rm = TRUE), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)),
                color = "black",
                size = 1) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_chinstrap, na.rm = TRUE), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)),
                geom = "area",
                xlim = c(194, lim_inf_boot_chinstrap),
                fill = "#a76bcf",
                alpha = 0.7) +
  stat_function(fun = dnorm,
                args = list(mean = mean(repeticoes_media_chinstrap, na.rm = TRUE), sd = sd(repeticoes_media_chinstrap, na.rm = TRUE)),
                geom = "area",
                xlim = c(lim_sup_boot_chinstrap, 198),
                fill = "#a76bcf",
                alpha = 0.7) +
  theme_bw() +
  labs(title = "Curva Normal das m√©dias geradas pelo BootStraping considerando IC",
      subtitle = "Para esp√©cie Chinstrap considerando a Vari√°vel Comprimento da Nadadeira",
      x = "Comprimento da Nadadeira (mm)",
      y = "Densidade") +
  geom_text(x = 197.5, y = 0.64, label = "Limite Inferior: 194.6 mm\nLimite Superior: 196.9 mm", alpha = 0.02) +
  theme(plot.background = element_rect(fill = "#fcfbf9"),
        legend.background = element_rect(fill = "#fcfbf9"),
        panel.background = element_rect(fill = "#fcfbf9"),
        legend.key = element_rect(fill = "#fcfbf9"),
        panel.border = element_rect(fill = "NA", color = "#fcfbf9"),
        plot.margin = margin(0,0,0,0))

grid.arrange(g5,g6)
```
Logo, podemos afirmar que h√° 95% de confian√ßa do intervalo [194.6, 196.9] conter o verdadeiro valor do par√¢metro.
:::


## Teste de Hip√≥tese!{.incremental}

 - Objetivo do Teste: Investigar se a propor√ß√£o de pinguins das esp√©cies Ad√©lie, Chinstrap e Gentoo no conjunto de dados Palmer Penguins difere significativamente de uma distribui√ß√£o equitativa, com uma propor√ß√£o hipot√©tica de 0.33333 e alpha 0.05 para cada esp√©cie.
 
 - Contexto: Exploramos as propor√ß√µes de cada esp√©cie de pinguim para entender se a distribui√ß√£o observada no conjunto de dados diverge da expectativa equitativa.
 
 - M√©todo: Utilizando testes de propor√ß√£o, analisaremos se as quantidades observadas de Ad√©lie, Chinstrap e Gentoo s√£o estatisticamente diferentes das propor√ß√µes esperadas.
 
## Teste de Hip√≥tese
::: {.panel-tabset}

### Ad√©lie
```{r, eval=TRUE, echo=TRUE}
# Teste de propor√ß√£o da QUANTIDADE de pinguins para a esp√©cie Adelie
# h0 √© igual a 0.33333
# h1 √© diferente de 0.33333
p0 = 0.33333
alpha = 0.05
n_dataset= length(penguins_db$species) # amostra total
n = length(species_separadas_adelie$species) # tamanho da esp√©cie ad√©lie no dt

p_chapeu_adelie = n/n_dataset # propor√ß√£o adelie/amostra total

z_adelie_1 = (p_chapeu_adelie-p0)/sqrt(p0*(1-p0)/n)
z_adelie_1

p_valor_adelie = pnorm(z_adelie_1)*2
p_valor_adelie

p_valor_adelie < alpha
# Como o pvalor √© maior alpha, aceitamos h0
# Portanto, ao n√≠vel de 5%,os dados mostram que a propor√ß√£o da popula√ß√£o de pinguins da esp√©cie Adelie √© igual a 0.3333(33%).
```

### Chinstrap
```{r, eval=TRUE, echo=TRUE}
# Teste para propor√ß√£o para a QUANTIDADE de pinguins da especie Chinstrap.
# h0 √© igual a 0.33333
# h1 √© diferente de 0.33333
n = length(species_separadas_chinstrap$species)
p_chapeu_chinstrap = n/n_dataset

z_chinstrap_1 = (p_chapeu_chinstrap-p0)/sqrt(p0*(1-p0)/n)
z_chinstrap_1

p_valor_chinstrap = pnorm(z_chinstrap_1)*2
p_valor_chinstrap

p_valor_chinstrap < alpha
# Como alpha √© maior que o pvalor, rejeitamos h0
# Ao n√≠vel de 5%,os dados mostram que a propor√ß√£o populacional de pinguins da esp√©cie Chinstrap diferente de 0.3333(33%).
```

### Gentoo
```{r, eval=TRUE, echo=TRUE}
# Teste para propor√ß√£o da QUANTIDADE de pinguins para a especie Gentoo
# h0 √© igual 0.3333
# h1 √© diferente de 0.3333
n = length(species_separadas_gentoo$species)
p_chapeu_gentoo = n/n_dataset

z_gentto_1 = (p_chapeu_gentoo-p0)/sqrt(p0*(1-p0)/n)
z_gentto_1

p_valor_gentoo = pnorm(z_gentto_1)*2
p_valor_gentoo

p_valor_gentoo < alpha
# Como pvalor √© maior que alpha, aceitamos h0
# Portanto, ao n√≠vel de 5%,os dados mostram que a propor√ß√£o da populacional de pinguins da esp√©cie Gentoo √© igual a 0.3333(33%).
```
:::